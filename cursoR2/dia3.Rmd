---
title: "Treinamento em Programação no Ambiente R"
author: "GENt"
date: "3/10/2020"
output:
  html_document: default
  pdf_document: default
---

# Dia 3

## Gráficos com ggplot

Antes de começarmos a fazer gráficos, vamos entender um pouco como o `ggplot` pensa sobre os dados.

```{r, warning=FALSE}
# obtendo o data.frame que contém os dados que queremos usar
info = read.csv("info_pessoal.csv", stringsAsFactors = FALSE)

# ver as primeiras linhas de um objeto
head(info)
```

Como iremos usar muito este data.frame `info`, vamos dar nomes mais convenientes para as colunas.

```{r}
colnames(info)

colnames(info) = c("horario", "genero", "participacao", "cidade", "instituicao", "escolaridade", "graduacao", 
                   "area", "idade", "altura", "peso", "aniversario", "conhecimentoR", "linguagens", "usoR", "motivacaoR")
```

### Funções ggplot() e aes()

Para criar qualquer gráfico usando ggplot, utilizamos a função `ggplot()` tendo como argumento um data.frame contendo todos os dados que iremos utilizar, independente do estilo de gráfico.

Uma função essencial do ggplot é chamada aesthetic, `aes()`, que irá passar todas as informações das variáveis a serem plotadas no gráfico. Dependendo do estilo do gráfico, precisaremos de diferentes variáveis para sua estética. Além disso, dependendo do gráfico, algumas podem ser obrigatórias ou não.

Aqui estão alguns exemplos de parâmetros de `aes()`:

* <b>x</b>: variável que ficará no eixo x
* <b>y</b>: variável que ficará no eixo y
* <b>color</b>: cor do contorno dos objetos
* <b>fill</b>: cor do preenchimento dos objetos
* <b>shape</b>: formato do ponto
* <b>size</b>: tamanho
* <b>linetype</b>: tipo da linha (contínua, pontilhada, tracejada)

### Gráficos de dispersão ou scatter plot

Após que sabemos que temos que usar um `ggplot()` e um `aes()`, vamos ver como isto funciona na prática!

Para fazer um gráfico de dispersão, vamos usar o nosso primeiro "geom", que será o `geom_point()`.

```{r, eval=FALSE}
library(ggplot2)

# para cada camada de informação, usaremos uma nova função separada por "+"
ggplot(info) + 
  geom_point(aes(x = peso, y = altura))

# vamos adicionando novas informações
ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = genero))

# mas tomar cuidado para não ter tanta informação demais
ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = genero, size = idade, shape = escolaridade))
```

Note que as variáveis que estamos usando, como peso, altura e gênero, estão todas dentro do data.frame info.

Vamos ver como deixar o gráfico mais apresentável.

```{r, eval=FALSE}
ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = genero)) +
  labs(title = "Meu primeiro scatter plot", x = "Peso (kg)", y = "Altura (m)", color = "Gênero")

ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = genero)) +
  labs(title = "Meu primeiro scatter plot", x = "Peso (kg)", y = "Altura (m)", color = "Gênero") +
  scale_color_manual(values = c("#F1290A", "#55BB29"))

ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = genero)) +
  labs(title = "Meu primeiro scatter plot", x = "Peso (kg)", y = "Altura (m)", color = "Gênero") +
  scale_color_manual(values = c("#F1290A", "#55BB29")) +
  theme(legend.position = "bottom") + theme_light()
```

Sugestão de site para escolher uma paleta de cores: <a href="https://color-hex.com">Color-Hex</a>

E se fôssemos relacionar o IMC das pessoas às informações de altura e peso?

```{r, eval=FALSE}
# Alternativa 1: uma escala de IMC
IMC.numerico = function(m, h){
  m/h^2
}

ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = IMC.numerico(peso, altura))) +
  labs(x = "Peso (kg)", y = "Altura (m)", color = "IMC") +
  scale_color_continuous(low = "blue", high = "red")


# Alternativa 2: categorias de IMC
IMC.categorico = function(m, h){
  imc = IMC.numerico(m, h)
  for (i in 1:length(imc)) {
    if(imc[i] < 18.5) {
      return("Magreza")
    } else if(imc[i] < 25) {
      return("Normal")
    } else if(imc[i] < 30) {
      return("Sobrepeso")
    } else if(imc[i] < 40) {
      return("Obesidade")
    } else {
      return("Obesidade grave")
    }
  }
}

ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = IMC.categorico(peso, altura))) +
  labs(x = "Peso (kg)", y = "Altura (m)", color = "IMC")
```


### Gráficos de barras e histogramas

Vamos pensar em como informar os perfis de alunos por curso de formação por gênero e por área de interesse.

```{r, eval=FALSE}
# GENERO
# posição: empilhamento
ggplot(info) + 
  geom_bar(aes(x = graduacao, fill = genero)) +
  labs(x = element_blank(), y = "Contagem", fill = "Gênero")

# posição: esquivando
ggplot(info) + 
  geom_bar(aes(x = graduacao, fill = genero), position = "dodge") +
  labs(x = element_blank(), y = "Contagem", fill = "Gênero")

# AREA DE INTERESSE
# posição: empilhamento
ggplot(info) + 
  geom_bar(aes(x = graduacao, fill = area)) +
  labs(x = element_blank(), y = "Contagem", fill = "Área de interesse") +
  coord_flip()

# posição: esquivando
ggplot(info) + 
  geom_bar(aes(x = graduacao, fill = area), position = "dodge") +
  labs(x = element_blank(), y = "Contagem", fill = "Área de interesse") +
  coord_flip()
```

Por vezes, é mais interessante subdividir a informação em mais de um gráfico.

```{r, eval=FALSE}
ggplot(info) +
  geom_bar(aes(x = graduacao, fill = genero)) +
  labs(x = element_blank(), y = "Contagem", fill = "Gênero") +
  facet_wrap(~ area) + coord_flip()

ggplot(info) +
  geom_bar(aes(x = graduacao, fill = area)) +
  labs(x = element_blank(), y = "Contagem", fill = "Área de interesse") +
  facet_wrap(~ genero) + coord_flip()
```

Outra forma de subdividir um gráfico em vários grupos é usando a camada `facet_grid()`, que permite organizar os gráficos do mesmo tipo em linhas, colunas ou matrizes de gráficos.

Para fazermos histogramas, é importante ajustar a largura das barras para representar aquilo que esperamos. Não existe uma regra muito clara que expresse bem qual o número de "bins" que devemos usar, então é importante fazer o teste com vários valores.

```{r, eval=FALSE}

# alterando o número de bins
ggplot(info) +
  geom_histogram(aes(x = altura), bins = 10) +
  labs(x = "Altura", y = "Contagem")

ggplot(info) +
  geom_histogram(aes(x = altura), bins = 20) +
  labs(x = "Altura", y = "Contagem")

# alterando a largura das bins
ggplot(info) +
  geom_histogram(aes(x = altura), binwidth = 0.1) +
  labs(x = "Altura", y = "Contagem")

ggplot(info) +
  geom_histogram(aes(x = altura), binwidth = 0.3) +
  labs(x = "Altura", y = "Contagem")

```

Os gráficos de densidade são bem bonitos de fazer, mas eles extrapolam informações a partir dos dados.

```{r, eval=FALSE}
ggplot(info) +
  geom_density(aes(x = altura)) +
  labs(x = "Altura", y = "Densidade")

ggplot(info) +
  geom_density(aes(x = altura)) +
  geom_point(aes(x = altura, y = 0.1), shape = "|", size = 10) +
  labs(x = "Altura", y = "Densidade")

```

# Para quem quiser saber mais

### Mapa

Para conseguir fazer esse mapa, é necessário usar o pacote brazilmaps, que você conseguirá instalar usando `install.packages("brazilmaps")`

```{r}
library(tidyverse)

estados = brazilmaps::get_brmap("State") 
estados$sigla = c("RO", "AC", "AM", "RR", "PA", "AP", "TO", "MA", "PI", "CE", "RN", "PB", "PE", "AL", "SE", "BA", "MG", "ES", "RJ", "SP", "PR", "SC", "MS", "MT", "GO", "DF", "RS")

estados = info %>%
  mutate(sigla = str_sub(cidade, nchar(cidade)-1, nchar(cidade))) %>%
  group_by(sigla) %>%
  summarise(n = n()) %>%
  right_join(estados, by = "sigla")

ggplot(estados) +
  geom_sf(aes(geometry = geometry, fill = n)) + 
  theme_minimal() + scale_fill_continuous(low = "gray40", high = "red")
```










