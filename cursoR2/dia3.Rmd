---
title: "Treinamento em Programação no Ambiente R"
author: "GENt"
date: "3/10/2020"
output:
  html_document: default
  pdf_document: default
---

# Dia 3

## Gráficos com ggplot

Antes de começarmos a fazer gráficos, vamos entender um pouco como o `ggplot` pensa sobre os dados.

```{r, warning=FALSE}
# obtendo o data.frame que contém os dados que queremos usar
info = read.csv("info_pessoal.csv", stringsAsFactors = FALSE)

# ver as primeiras linhas de um objeto
knitr::kable(head(info))
```

Como iremos usar muito este data.frame `info`, vamos dar nomes mais convenientes para as colunas.

```{r}
colnames(info)

colnames(info) = c("horario", "genero", "participacao", "cidade", "instituicao", "escolaridade", "graduacao", 
                   "area", "idade", "altura", "peso", "aniversario", "conhecimentoR", "linguagens", "usoR", "motivacaoR")
```

### Funções ggplot() e aes()

Para criar qualquer gráfico usando ggplot, utilizamos a função `ggplot()` tendo como argumento um data.frame contendo todos os dados que iremos utilizar, independente do estilo de gráfico.

Uma função essencial do ggplot é chamada aesthetic, `aes()`, que irá passar todas as informações das variáveis a serem plotadas no gráfico. Dependendo do estilo do gráfico, precisaremos de diferentes variáveis para sua estética. Além disso, dependendo do gráfico, algumas podem ser obrigatórias ou não.

Aqui estão alguns exemplos de parâmetros de `aes()`:

* <b>x</b>: variável explicativa
* <b>y</b>: variável resposta
* <b>color</b>: cor do contorno dos objetos
* <b>fill</b>: cor do preenchimento dos objetos
* <b>shape</b>: formato do ponto
* <b>size</b>: tamanho
* <b>linetype</b>: tipo da linha (contínua, pontilhada, tracejada)

### Gráficos de dispersão ou scatter plot

Após que sabemos que temos que usar um `ggplot()` e um `aes()`, vamos ver como isto funciona na prática!

Para fazer um gráfico de dispersão, vamos usar o nosso primeiro "geom", que será o `geom_point()`.

```{r, eval=FALSE}
library(ggplot2)

# para cada camada de informação, usaremos uma nova função separada por "+"
ggplot(info) + 
  geom_point(aes(x = peso, y = altura))

# vamos adicionando novas informações
ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = genero))

# mas tomar cuidado para não ter tanta informação demais
ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = genero, size = idade, shape = escolaridade))
```

Note que as variáveis que estamos usando, como peso, altura e gênero, estão todas dentro do data.frame info.

Vamos ver como deixar o gráfico mais apresentável.

```{r, eval=FALSE}
ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = genero)) +
  labs(title = "Meu primeiro scatter plot", x = "Peso (kg)", y = "Altura (m)", color = "Gênero")

ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = genero)) +
  labs(title = "Meu primeiro scatter plot", x = "Peso (kg)", y = "Altura (m)", color = "Gênero") +
  scale_color_manual(values = c("#F1290A", "#55BB29"))

ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = genero)) +
  labs(title = "Meu primeiro scatter plot", x = "Peso (kg)", y = "Altura (m)", color = "Gênero") +
  scale_color_manual(values = c("#F1290A", "#55BB29")) +
  theme_light() +
  theme(legend.position = "bottom") 
```

Sugestão de site para escolher uma paleta de cores: <a href="https://color-hex.com">Color-Hex</a>

E se fôssemos relacionar o IMC das pessoas às informações de altura e peso?

```{r, eval=FALSE}
# Alternativa 1: uma escala de IMC
IMC.numerico = function(m, h){
  m/h^2
}

ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = IMC.numerico(peso, altura))) +
  labs(x = "Peso (kg)", y = "Altura (m)", color = "IMC") +
  scale_color_continuous(low = "blue", high = "red")


# Alternativa 2: categorias de IMC
IMC.categorico = function(m, h){
  imc = IMC.numerico(m, h)
  for (i in 1:length(imc)) {
    if(imc[i] < 18.5) {
      return("Magreza")
    } else if(imc[i] < 25) {
      return("Normal")
    } else if(imc[i] < 30) {
      return("Sobrepeso")
    } else if(imc[i] < 40) {
      return("Obesidade")
    } else {
      return("Obesidade grave")
    }
  }
}

ggplot(info) + 
  geom_point(aes(x = peso, y = altura, color = IMC.categorico(peso, altura))) +
  labs(x = "Peso (kg)", y = "Altura (m)", color = "IMC")
```


### Gráficos de barras e histogramas

Vamos pensar em como informar os perfis de alunos por curso de formação por gênero e por área de interesse.

```{r, eval=FALSE}
# GENERO
# posição: empilhamento
ggplot(info) + 
  geom_bar(aes(x = graduacao, fill = genero)) +
  labs(x = element_blank(), y = "Contagem", fill = "Gênero")

# posição: esquivando
ggplot(info) + 
  geom_bar(aes(x = graduacao, fill = genero), position = "dodge") +
  labs(x = element_blank(), y = "Contagem", fill = "Gênero")

# AREA DE INTERESSE
# posição: empilhamento
ggplot(info) + 
  geom_bar(aes(x = graduacao, fill = area)) +
  labs(x = element_blank(), y = "Contagem", fill = "Área de interesse") +
  coord_flip()

# posição: esquivando
ggplot(info) + 
  geom_bar(aes(x = graduacao, fill = area), position = "dodge") +
  labs(x = element_blank(), y = "Contagem", fill = "Área de interesse") +
  coord_flip()
```

Por vezes, é mais interessante subdividir a informação em mais de um gráfico.

```{r, eval=FALSE}
ggplot(info) +
  geom_bar(aes(x = graduacao, fill = genero)) +
  labs(x = element_blank(), y = "Contagem", fill = "Gênero") +
  facet_wrap(~ area) + coord_flip()

ggplot(info) +
  geom_bar(aes(x = graduacao, fill = area)) +
  labs(x = element_blank(), y = "Contagem", fill = "Área de interesse") +
  facet_wrap(~ genero) + coord_flip()
```

Outra forma de subdividir um gráfico em vários grupos é usando a camada `facet_grid()`, que permite organizar os gráficos do mesmo tipo em linhas, colunas ou matrizes de gráficos.

Para fazermos histogramas, é importante ajustar a largura das barras para representar aquilo que esperamos. Não existe uma regra muito clara que expresse bem qual o número de "bins" que devemos usar, então é importante fazer o teste com vários valores.

```{r, eval=FALSE}

# alterando o número de bins
ggplot(info) +
  geom_histogram(aes(x = altura), bins = 10) +
  labs(x = "Altura", y = "Contagem")

ggplot(info) +
  geom_histogram(aes(x = altura), bins = 20) +
  labs(x = "Altura", y = "Contagem")

# alterando a largura das bins
ggplot(info) +
  geom_histogram(aes(x = altura), binwidth = 0.1) +
  labs(x = "Altura", y = "Contagem")

ggplot(info) +
  geom_histogram(aes(x = altura), binwidth = 0.3) +
  labs(x = "Altura", y = "Contagem")

```

Os gráficos de densidade são bem bonitos de fazer, mas eles extrapolam informações a partir dos dados.

```{r, eval=FALSE}
ggplot(info) +
  geom_density(aes(x = altura)) +
  labs(x = "Altura", y = "Densidade")

ggplot(info) +
  geom_density(aes(x = altura)) +
  geom_point(aes(x = altura, y = 0.1), shape = "|", size = 10) +
  labs(x = "Altura", y = "Densidade")

```

## Boxplots e violin plots

Estes tipos de gráficos são comumente usados para visualizar as tendências gerais dos dados e são muito utilizados pela comunidade científica.

```{r, eval=FALSE}
ggplot(info) +
  geom_boxplot(aes(x = escolaridade, y = conhecimentoR)) +
  labs(x = element_blank(), y = "Conhecimento prévio em R")

ggplot(info) +
  geom_violin(aes(x = area, y = conhecimentoR)) +
  labs(x = element_blank(), y = "Conhecimento prévio em R")
```

Agora vamos pensar numa pergunta mais interessante. Será que o número de linguagens que a pessoa conhece previamente está relacionada com o conhecimento prévio em R? Para isto, teremos que descobrir a partir de `info$linguagens` qual a quantidade de linguagens de programação cada pessoa conhece. 

<b> Vamos fazer este exercício juntos! </b>

### PCA - Análise de componentes principais

O PCA é uma análise exploratória muito frequente quando utilizada por usuários que possuem muitos dados. Nela, torna-se possível visualizar dados que deveriam ter diversas dimensões em apenas duas componentes mais informativas. Para isto, usamos a função `autoplot()`.

```{r, eval=FALSE}
# para instalar, use install.packages("ggfortify")
library(ggfortify)

autoplot(prcomp(~ conhecimentoR + altura + peso + idade, data = info),
         data = info, shape = 'area', colour = 'graduacao', loadings = TRUE, loadings.colour = 'red', 
         loadings.label = TRUE, loadings.label.colour = 'black',
         loadings.label.size = 4) +
  labs(shape = "Área de \ninteresse", color = "Formação", title = "PCA")

# Os parâmetros relacionados com "LOADINGS" são na verdade a direção onde a váriável mais cresce em duas dimensões
# Ela serve apenas como uma aproximação, já que os dados reais precisariam de mais dimensões, que nosso olho não pode ver
```

Agora que você fez um plot de PCA, você pode perceber que ele é apenas uma variação do `geom_point()`, isto permite que você adicione todas as camadas de ggplot que você quiser sobre este gráfico. Já fizemos isto com as legendas!

# Para quem quiser saber mais

### Mapa

Não vamos entrar em detalhe sobre os códigos que usamos aqui porque ele faz uso do `tidyverse`, um pacote que permite manipular os dados com muita flexibilidade, mas ele iria requerer outro curso focado apenas nele! Esta é uma aplicação para mostrar que conseguimos fazer quase tudo com R e ggplot em mãos. O mais difícil é saber manipular os dados...

```{r, eval=F}
library(tidyverse)

# Coletando os dados da base por estado
estados = brazilmaps::get_brmap("State")

# Adicionando uma coluna com as siglas dos estados, será importane para a próxima etapa
estados$sigla = c("RO", "AC", "AM", "RR", "PA", "AP", "TO", "MA", "PI", "CE", "RN", "PB", "PE", "AL", "SE", "BA", "MG", "ES", "RJ", "SP", "PR", "SC", "MS", "MT", "GO", "DF", "RS")

# Aqui, estamos pegando as duas últimas letras da cidade de origem da pessoa,
# se ela tiver preenchido corretamente, estas últimas serão o estado, como em
# "Piracicaba - SP". Após isto, fazemos a contagem de pessoas por estado e 
# unimos com os dados do brazilmaps
estados = info %>%
  mutate(sigla = str_sub(cidade, nchar(cidade)-1, nchar(cidade))) %>%
  group_by(sigla) %>%
  summarise(n = n()) %>%
  right_join(estados, by = "sigla")

# Aqui usamos um outro tipo de plot, o geom_sf(), que precisa de dados de
# coordenadas geométricas para construir os mapas. O resto envolve apenas
# funções e argumentos que nós conhecemos!!!
ggplot(estados) +
  geom_sf(aes(geometry = geometry, fill = n)) + 
  theme_minimal() + scale_fill_continuous(low = "gray40", high = "red") +
  labs(fill = "Número \nde pessoas")
```

Para conseguir fazer esse mapa, é necessário usar o pacote brazilmaps, que você conseguirá instalar usando `install.packages("brazilmaps")`
